1. 서술형
자바의 기본 데이터 타입과 참조 데이터 타입의 차이를 서술하시오.

의미, 종류, 저장되는 것, 예시(변수 1개)

기본 데이터 타입(Primitive Type) - ‘값 자체를 저장하는 타입’
<aside> ????

답안

정수, 실수, 문자, 논리 값을 저장

총 8가지 타입: byte, short, int, long, float, double, char, boolean.

값이 메모리의 스택(stack) 영역에 직접 저장

예: int age = 25; </aside>

참조 데이터 타입(Reference Type)

→ ‘메모리의 주소를 저장하는 타입’

<aside> ????

답안

객체, 배열, 클래스, 인터페이스 등을 참조
변수는 힙(heap) 영역에 저장된 데이터를 가리키는 참조 주소를 스택(stack)에 저장
예: String name = "John"; (String은 참조 타입) </aside>
+) 주요 차이점

기본 데이터 타입은 값 자체를 저장하고, 참조 데이터 타입은 힙 메모리의 주소를 저장합니다.
참조 데이터 타입은 추가 메서드와 기능을 제공할 수 있습니다.
2. 코드 구현 문제
다음 요구사항을 만족하는 코드를 작성하세요.

<aside> ????

요구사항

int 타입의 변수 num1에 10, double 타입의 변수 num2에 3.5를 저장합니다.
두 변수를 더한 결과를 double 타입의 변수 result에 저장합니다.
결과 값을 출력합니다. </aside>
<aside> ????

답안

// 변수 선언 및 초기화 int num1 = 10; // int 타입 변수 num1에 10 저장 double num2 = 3.5; // double 타입 변수 num2에 3.5 저장 // 2. 두 변수의 합을 계산하여 result 변수에 저장 double result = num1 + num2; // 3. 결과 출력 System.out.println("결과: " + result); // 결과 출력

</aside>

3. 코드 구현 문제
다음 요구사항을 만족하는 코드를 작성하세요.

<aside> ????

요구사항:

사용자로부터 int 타입의 숫자 하나를 입력받습니다.
입력받은 숫자가 짝수인지 홀수인지 판단하여 출력합니다.
짝수인 경우: "입력하신 숫자는 짝수입니다."
홀수인 경우: "입력하신 숫자는 홀수입니다." </aside>
<aside> ????

답안

// Scanner를 사용하여 사용자로부터 숫자 입력받기 Scanner scanner = new Scanner(System.in); System.out.print("숫자를 입력하세요: "); int number = scanner.nextInt(); // 2. 짝수인지 홀수인지 판단 if (number % 2 == 0) {    System.out.println("입력하신 숫자는 짝수입니다."); } else {    System.out.println("입력하신 숫자는 홀수입니다."); } // 3. Scanner 닫기 scanner.close();

</aside>

4. 코드 구현 문제
for-each 반복문을 사용하여 배열 요소를 출력할 때 적합한 코드를 작성하세요.

int[] numbers = {1, 2, 3, 4, 5}; // 정답 작성 // for

<aside> ????

답안

// 배열 선언 및 초기화 int[] numbers = {1, 2, 3, 4, 5}; // for-each 반복문을 사용하여 배열 요소 출력 for (int num : numbers) {    System.out.println(num); }

</aside>

5. 코드 구현 문제
다음 요구사항을 만족하는 코드를 작성하세요.

<aside> ????

요구사항:

Student라는 클래스를 작성합니다.
name (이름, 문자열 타입)과 score (점수, 정수 타입) 필드를 가집니다.
Student 객체를 생성할 때 이름과 점수를 초기화할 수 있는 생성자를 만듭니다.
Student 객체 배열을 생성하여 학생 5명의 이름과 점수를 초기화합니다.
예: 학생 이름: "John", "Jane", "Tom", "Emily", "Alex" / 점수: 85, 92, 78, 88, 95
반복문을 사용하여 점수가 90점 이상인 학생의 이름을 출력합니다. </aside>
<aside> ????

답안

class Student {    private String name; // 이름    private int score;   // 점수    // 생성자    public Student(String name, int score) {        this.name = name;        this.score = score;    }    // 이름을 반환하는 메서드    public String getName() {        return name;    }    // 점수를 반환하는 메서드    public int getScore() {        return score;    } } public class Test {    public static void main(String[] args) {        // 1. Student 객체 배열 생성 및 초기화        Student[] students = {            new Student("이승아", 85),            new Student("이도경", 92),            new Student("이지희", 78),            new Student("이지훈", 88),            new Student("김명진", 95)        };        // 2. 점수가 90점 이상인 학생의 이름 출력        System.out.println("90점 이상인 학생:");        for (Student student : students) {            if (student.getScore() >= 90) {                System.out.println(student.getName());            }        }    } }

</aside>

6. 단답형
자바에서 모든 클래스의 최상위 부모 클래스는 무엇입니까?

정답: Object

→ 자바의 모든 클래스는 암시적으로 Object 클래스를 상속받음

→ Object 클래스가 가진 toString(), equals() 등의 메서드를 기본적으로 가짐

7. 단답형
ArrayList와 같은 컬렉션에서 요소의 개수를 반환하는 메서드는 무엇입니까?

정답: size()

→ 리스트에 저장된 요소의 개수를 반환

8. 단답형
자바에서 if-else 문 대신 간결하게 조건에 따라 값을 반환할 수 있는 연산자는 무엇입니까?

정답: 삼항 연산자 (? :)

→ 조건식 ? 참일 때 값 : 거짓일 때 값

→ int result = ( a > b) ? a : b;

9. 다음 중 인터페이스에서 사용할 수 없는 것은 무엇입니까?
→ 추상 메서드, default 메서드, static(정적) 메서드

default 메서드

정적 메서드

private 메서드

→ 접근제어자가 생략된 메서드의 경우 기본으로 public abstract 으로만 선언

→ default와 static 메서드에서 private 접근제어자 사용이 가능

단, private 메서드는 인터페이스 내부에서만 호출 가능
생성자 (✅)

정답: 4. 생성자

<aside> ????

해설

인터페이스 자체로는 객체를 생성할 수 없으며, 생성자도 가질 수 없음

→ 인터페이스는 객체의 구조를 정의하는 데 집중하기 때문에 생성자와 같이 객체를 직접적으로 생성하는 요소를 포함하지 않음

</aside>

10. 다음 중 @FunctionalInterface에 해당하는 조건으로 올바른 것은 무엇입니까?
여러 개의 추상 메서드 포함 가능

반드시 하나의 추상 메서드 포함 (✅)

→ 단, 하나의 추상 메서드만 허용 / default 와 static 메서드에 대한 추가 정의가 불가 !

default 메서드를 포함할 수 없음

정적 메서드만 포함 가능

정답: 2. 반드시 하나의 추상 메서드 포함

11: 다음 코드에서 출력 결과는 무엇입니까?
class Parent { void display() { System.out.println("Parent"); } } class Child extends Parent { void display() { System.out.println("Child"); } } public class Main { public static void main(String[] args) { Parent obj = new Child(); obj.display(); } }

결과: Child

<aside> ????

해설

// 1. 객체 생성과 업캐스팅 Parent obj = new Child(); // obj는 Parent 타입의 참조 변수이지만, 실제로 참조하는 객체는 Child // -> 업캐스팅, 런타임에 실제 객체의 메서드가 호출 // 2. 다형성(Polymorphism) obj.display(); // display 메서드는 Child 클래스에서 재정의(오버라이딩) // -> obj.display()는 Parent의 메서드가 아닌 Child의 메서드를 호출 // 따라서) Child 가 출력

Child 클래스에서 display() 메서드를 재정의했기 때문에 실행 시점에 실제 객체의 메서드가 호출
업캐스팅된 객체에서 메서드를 호출할 때는 오버라이딩된 메서드가 실행 - 동적 바인딩
‘업캐스팅’에서 자식 메서드 실행 가능 여부

1) 오버라이딩 된 메서드 → 부모 클래스에서 정의된 메서드를 자식 클래스에서 오버라이딩한 경우 , 자식 클래스의 메서드가 호출 → 업캐스팅과 상관없이 실제 객체(Child)의 메서드가 실행

2) 자식만이 가진 고유 메서드 → 업캐스팅 된 상태에서는 부모 객체 변수로 자식 클래스의 고유 메서드 호출이 불가 → 자식 메서드 호출 시 다운 캐스팅이 필요

</aside>

12: 싱글톤 패턴을 구현할 때 가장 일반적으로 사용되는 메서드는 무엇입니까?
public static(✅)
private static
protected static
default static
정답: public static

<aside> ????

해설

싱글톤 패턴은 애플리케이션 전체에서 단 하나의 객체만 생성되도록 보장하는 디자인 패턴

→ public static 메서드(일반적으로 getInstance)를 사용하여 객체를 반환

</aside>

13: 추상 클래스
추상 클래스는 (직접) 객체를 생성할 수 있습니까?

예
아니요 (✅)
<aside> ????

해설

추상 클래스는 객체의 공통적인 속성과 동작을 정의

→ 불완전한 설계(추상 메서드 포함)를 가지므로, 단독으로 객체를 생성할 수 없음 → 추상 클래스를 상속받은 구체적인 클래스(Concrete Class)에서 추상 메서드를 구현한 후 객체를 생성

‘자식 클래스’가 추상 메서드를 모두 구현한 후에 객체 생성이 가능 </aside>

14: 다운 캐스팅
다음 코드에서 다운 캐스팅이 성공하려면 어떤 조건이 필요합니까?

Animal animal = new Dog(); Dog dog = (Dog) animal;

정답: animal 참조 변수가 실제로 Dog 객체를 참조하고 있어야 한다.

<aside> ????

해설

다운 캐스팅

→ 부모 클래스 타입으로 선언된 객체를 자식 클래스 타입으로 변환하는 것

참조 변수가 실제로 자식 클래스 객체를 참조하고 있어야 다운 캐스팅이 성공

그렇지 않으면 ClassCastException이 발생

instanceof 사용 → 다운 캐스팅이 가능한지 안전하게 확인하려면 instanceof 연산자를 사용

</aside>

15: 빌더 패턴의 주요 이점은 무엇입니까?
상속 관계에서 객체를 더 쉽게 생성할 수 있다.
객체 생성 시 복잡한 생성자 호출을 피할 수 있다. (✅)
동시성 처리를 쉽게 한다.
객체의 메모리 사용을 줄인다.
정답: 2. 객체 생성 시 복잡한 생성자 호출을 피할 수 있다.

→ 필드가 많거나 생성자 매개변수가 복잡한 객체를 쉽게 생성하도록 도와줌

16: MVC 패턴에서 사용자의 입력을 처리하는 역할은 무엇입니까?
Model

View

Controller (✅)

→ 사용자 입력을 처리하고, 모델과 뷰를 연결하는 역할

정답: Controller

17: 인터페이스의 모든 메서드는 기본적으로 어떤 접근 제어자를 가집니까?
정답: public (모든 메서드는 ‘기본적’으로 public이며, abstract 키워드는 생략 가능)

→ 자바 9부터 private 메서드를 인터페이스 내부에서 사용 가능

18: 추상 클래스와 인터페이스의 주요 차이점 중 맞지 않는 것은 무엇입니까?
추상 클래스는 생성자를 가질 수 있다. VS 인터페이스는 생성자를 가질 수 없다.
인터페이스는 다중 상속을 지원한다. VS 추상 클래스는 다중 상속을 지원하지 않는다.
인터페이스는 필드를 가질 수 없다. VS 추상 클래스 필드를 가질 수 있다.
추상 클래스는 정적 메서드를 가질 수 없다. (✅)
정답: 4. 추상 클래스는 정적 메서드를 가질 수 없다

→ 추상 클래스는 static 메서드를 가질 수 있음 !

→ 인터페이스도 static 메서드를 가질 수 있음 !